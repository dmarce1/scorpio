array3d.h:			data = new T[NX * NY * NZ];
binary_star/binary_star_static.cpp:     char* buf = new char[sz];
binary_star/binary_star.h:        return new BinaryStar;
binary_star/binary_star_read.cpp:    frame->node_list = new node_t[frame->node_count];
bits.h:		a = new byte_t[cnt];
blast_wave/grid_blast_wave.cpp:    return new GridBlastWave;
blast_wave/grid_blast_wave.cpp:    radial_avg = new Vector<Real, 4> [radial_N];
blast_wave/grid_blast_wave.cpp:    radial_bin_cnt = new int[radial_N];
blast_wave/grid_blast_wave.cpp:    radial_avg_tmp = new Vector<Real, 4> [radial_N];
blast_wave/grid_blast_wave.cpp:    radial_bin_cnt_tmp = new int[radial_N];
blast_wave/grid_blast_wave.cpp:        Real* rpos = new double[radial_N];
blast_wave/grid_blast_wave.cpp:        Real* ad = new double[radial_N];
blast_wave/grid_blast_wave.cpp:        Real* av = new double[radial_N];
blast_wave/grid_blast_wave.cpp:        Real* ae = new double[radial_N];
FMM/FMM.cpp:        moment_buffer = new multipole_t[INX * INX * INX / 8];
FMM/FMM.cpp:        moment_dot_buffer = new multipole_dot_t[INX * INX * INX / 8];
FMM/FMM.cpp:        taylor_buffer = new taylor_t[INX * INX * INX / 8];
FMM/FMM.cpp:        taylor_dot_buffer = new taylor_dot_t[INX * INX * INX / 8];
FMM/FMM.cpp:    FMM** list = new FMM*[get_local_node_cnt()];
FMM/FMM.cpp:    FMM** list = new FMM*[get_local_node_cnt()];
FMM/FMM.cpp:    FMM** list = new FMM*[get_local_node_cnt()];
FMM/FMM.cpp:    FMM** list = new FMM*[get_local_node_cnt()];
FMM/FMM.cpp:    return new FMM;
FMM/FMM.cpp:        _4force_buffer = new _4force_t[INX * INX * INX / 8];
hydro/legendre.cpp:		cons = new Real*[lmax + 1];
hydro/legendre.cpp:			cons[l] = new Real[2 * l + 1];
hydro/hydro_static.cpp:    send_list = new Hydro*[count];
hydro/hydro_static.cpp:    Hydro** list = new Hydro*[get_local_node_cnt()];
hydro/hydro_static.cpp:    Hydro** list = new Hydro*[get_local_node_cnt()];
hydro/hydro_static.cpp:    Hydro** list = new Hydro*[get_local_node_cnt()];
hydro/hydro_static.cpp:    Hydro** list = new Hydro*[get_local_node_cnt()];
hydro/hydro.cpp:                        mpi_amr_buffer[2 * dir][amr_cnt[dir]] = new State[sz];
hydro/hydro.cpp:        mpi_buffer[0] = new State[(GNX / 2 - BW) * (GNX / 2 - BW) * (GNX / 2 - BW)];
hydro/hydro.cpp:            mpi_buffer[f] = new State[sz];
hydro/hydro.cpp:            mpi_buffer[f] = new State[sz];
hydro/hydro.cpp:            mpi_buffer[f] = new State[sz];
hydro/hydro.cpp:                    mpi_amr_buffer[f][ci] = new State[sz];
hydro/hydro.cpp:                            mpi_amr_buffer[f][ci] = new State[sz];
hydro/hydro.cpp:        mpi_buffer[0] = new State[(GNX - 2 * BW) * (GNX - 2 * BW) * (GNX - 2 * BW)];
legendre.h:		P = new Real*[lmax + 1];
legendre.h:			P[l] = new Real[2 * l + 1];
legendre.h:		Y = new Complex*[lmax + 1];
legendre.h:			Y[l] = new Complex[2 * l + 1];
oct_node/oct_node.cpp:        local_node = new OctNode*[get_node_cnt()];
oct_node/oct_node.cpp:    output_buffer = new Real[this->nvar_output() * (nx0 - 2 * bw0) * (nx0 - 2 * bw0) * (nx0 - 2 * bw0)];
oct_node/oct_node.cpp:            coordnames[i] = new char[2];
oct_node/oct_node.cpp:            coords[i] = reinterpret_cast<float*>(new OReal[nnodes]);
oct_node/oct_node.cpp:        go.nodelist = new int[8 * nzones];
oct_node/oct_node.cpp:        go.ele = new OReal*[nf];
oct_node/oct_node.cpp:            go.ele[i] = new OReal[nzones];
program.cpp:    ProblemGrid* root = new ProblemGrid;
sod/grid_sod.cpp:    return new GridSod;
sod/grid_sod.cpp:    line_avg = new Vector<Real, 5> [line_N];
sod/grid_sod.cpp:    line_bin_cnt = new int[line_N];
sod/grid_sod.cpp:    line_avg_tmp = new Vector<Real, 5> [line_N];
sod/grid_sod.cpp:    line_bin_cnt_tmp = new int[line_N];
sod/grid_sod.cpp:        Real* xpos = new double[line_N];
sod/grid_sod.cpp:        Real* ad = new double[line_N];
sod/grid_sod.cpp:        Real* av = new double[line_N];
sod/grid_sod.cpp:        Real* ap = new double[line_N];
